package _6_class._2_objectAndClass;

// 클래스 구성 멤버: 필드(Field), 생성자(Constructor), 메소드(Method)
// 1. 필드: 객체의 데이터가 저장되는 곳.
//         변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다.
//         하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
//         클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.

// 2. 생성자: 객체 생성 시 초기화 역할 담당.
//          new 연산자로 호출되는 특별한 중괄호 블록이다. 객체 생성시 초기화를 담당한다.
//          필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다. 클래스 이름으로 되어 있고 리턴 타입이 없다.
//          생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
//          생성자 선언을 생략했다면 컴파일러는 기본 생성자를 바이트 코드에 자동 추가시킨다.
//          명시적 생성자가 있으면 컴파일러가 기본 생성자 추가 안한다.
//          클래스가 public 이면 기본 생성자도 public, 아니면 안붙는다.

// 3. 메소드: 객체의 동작에 해당하는 실행 블록.
//          메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
//          객체 간 데이터 전달 수단으로 사용된다. 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.

// 생성자 오버로딩(Overloading): 다양한 방법으로 객체를 생성할 수 있다. 매개 변수를 달리하는 생성자를 여러 개 선언하는 것.
// 다른 생성자 호출(this()): this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.
public class ClassEx2 {
    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = new Car(2);

        System.out.println("Car1::" + car1.doorCnt);
        System.out.println("Car2::" + car2.doorCnt);

        Car car3 = new Car(2, 20);
        System.out.println(car3.doorCnt + "::" + car3.speed);
    }
}
