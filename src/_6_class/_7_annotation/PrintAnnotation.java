package _6_class._7_annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 어노테이션은 엘리먼트(element)를 멤버로 가질 수 있다.
// 어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다.
// @Target 의 기본 엘리먼트인 value 는 ElementType 배열을 값으로 가진다. 어노테이션이 적용될 대상 복수개로 지정 가능.
// -------------------------------------------------------------------------------
// ElementType 열거 상수        적용 대상
// -------------------------------------------------------------------------------
// TYPE                       클래스, 인터페이스, 열거 타입
// ANNOTATION_TYPE            어노테이션
// FIELD                      필드
// CONSTRUCTOR                생성자
// METHOD                     메소드
// LOCAL_VARIABLE             로컬 변수
// PACKAGE                    패키지
// -------------------------------------------------------------------------------

// 어노테이션을 어느 범위까지 유지할 것인지 지정해야 한다. 소스상에만 유지할 건지, 컴파일된 클래스까지 유지할 건지, 런타임 시에도 유지할 건지를 지정해야 한다.
// -------------------------------------------------------------------------------
// RetentionPolicy 열거 상수    설명
// -------------------------------------------------------------------------------
// SOURCE                     소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에서는 정보가 남지 않는다.
// CLASS                      바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.
// RUNTIME                    바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다.
// -------------------------------------------------------------------------------
// 리플렉션(Reflection): 런타임 시에 클래스의 메타 정보를 얻는 기능.
// 코드 자동 생성 툴을 개발하지 않는 이상 우리가 작성하는 어노테이션은 대부분 런타임 시점에 사용하기 위한 용도로 만들어진다.

// 런타임 시에 어노테이션이 적용되었는지 확인하고 엘리먼트 값을 이용해서 특정 작업을 수행하는 방법
// 1. 클래스에 적용된 어노테이션 정보를 얻으려면 java.lang.Class
// 2. 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class 의 다음 메소드를 통해서 java.lang.reflect 패키지의 Field, Constructor, Method 타입 배열을 얻어야 한다.
// -------------------------------------------------------------------------------
// 리턴 타입        메소드명(매개 변수)         설명
// -------------------------------------------------------------------------------
// Field[]        getFields()            필드 정보를 Field 배열로 리턴
// Constructor[]  getConstructors()      생성자 정보를 Constructor 배열로 리턴
// Method[]       getDeclaredMethods()   메소드 정보를 Method 배열로 리턴
// -------------------------------------------------------------------------------

// 그런 다음 Class, Field, Constructor, Method 가 가지고 있는 다음 메소드를 호출해서 적용된 어노테이션 정보를 얻을 수 있다.
// -------------------------------------------------------------------------------
// 리턴 타입        메소드명(매개 변수)
// -------------------------------------------------------------------------------
// boolean        isAnnotationPresent(Class<? extends Annotation> annotationClass)
//                지정한 어노테이션이 적용되었는지 여부. Class 에서 호출했을 때 상위 클래스에 적용된 경우에도 true 를 리턴한다.
// Annotation     getAnnotation(Class<T> annotationClass)
//                지정한 어노테이션이 적용되어 있으면 어노테이션을 리턴하고 그렇지 않다면 null 을 리턴한다.
//                Class 에서 호출했을 때 상위 클래스에 적용된 경우에도 어노테이션을 리턴한다.
// Annotation[]   getAnnotations()
//                적용된 모든 어노테이션을 리턴한다. Class 에서 호출했을 때 상위 클래스에 적용된 어노테이션도 모두 포함한다.
//                적용된 어노테이션이 없을 경우 길이가 0인 배열을 리턴한다.
// Annotation[]   getDeclaredAnnotations()
//                직접 적용된 모든 어노테이션을 리턴한다. Class 에서 호출했을 때 상위 클래스에 적용된 어노테이션은 포함되지 않는다.
// -------------------------------------------------------------------------------

// 커스텀 어노테이션에 javax.validation 의 constraint, payload 도 추가할 수 있다.

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface PrintAnnotation {
    // 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.
    // 디폴트 값이 없으면 반드시 값을 기술해야 한다.
    String value() default "-";

    int number() default 15;
}
