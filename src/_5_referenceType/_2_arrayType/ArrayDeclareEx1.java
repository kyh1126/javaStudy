package _5_referenceType._2_arrayType;

// 배열: 같은 타입의 데이터만 저장할 수 있다. 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다.
//      한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다. 참조 변수에 속하기 때문에 힙 영역에 생성되고 배열 변수는 힙 영역 배열 객체를 참조.
//      참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화될 수 있다.
//      배열 속의 배열은 다른 크기로 지정될 수 있다.

// 타입별 배열의 초기값
// -------------------------------------------------------------------------------
// 분류           데이터 타입      초기값
// -------------------------------------------------------------------------------
// 기본 타입(정수)  byte[]        0
//               char[]        "\u0000"
//               short[]       0
//               int[]         0
//               long[]        0L
// -------------------------------------------------------------------------------
// 기본 타입(실수)  float[]       0.0F
//               double[]     0.0
// -------------------------------------------------------------------------------
// 기본 타입(논리)  boolean[]     false
// -------------------------------------------------------------------------------
// 참조 타입       클래스[]        null
//               인터페이스[]     null
// -------------------------------------------------------------------------------

import java.util.Arrays;

// 프로그램 실행 시 main() 메소드가 필요한데, main() 메소드의 매개값인 String[] args 는 왜 필요한가?
// "java 클래스"로 프로그램을 실행하면 JVM 은 길이가 0인 String 배열을 먼저 생성하고 main() 메소드를 호출할 때 매개값으로 전달한다.
public class ArrayDeclareEx1 {
    public static void main(String[] args) {
        // 스택           힙
        Integer[] arr = {null, null, null};
        int[] arr2;
        // 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다.
//        arr2 = {1, 2};
        // new 연산자를 사용해서 값 목록을 지정해주면 된다.
        arr2 = new int[]{1, 2};
        // 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들기
        // 값이 저장될 수 있는 공간을 확보하고, 배열의 생성 번지를 리턴한다.
        int[] arr3 = new int[3];
        arr[1] = 3;

        // 얕은 복사: 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일
        // 깊은 복사: 참조하는 객체도 별도로 생성하는 것
        // 얕은 복사, 원본 배열, 시작 인덱스, 새 배열, 붙여넣을 시작 인덱스, 복사할 개수
        System.arraycopy(arr2, 1, arr3, 2, 1);
        Arrays.stream(arr3).forEach(System.out::println);
    }
}
